@알고리즘

* A*알고리즘
참고링크
- http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
- https://www.redblobgames.com/pathfinding/grids/graphs.html
- http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#polygonal-maps

-- 다익스트라 와의 차이점
=> 완전한 최단경로를 찾지 않고 최단경로의 근사값을 찾아내는(휴리스틱) 것을 목표
-- 휴리스틱 추정값 f(n) = g(n) + h(n),  " h(x) "  =>적절한 휴리스틱값 설정여부
-- 장애물의 그래프 표현
1. 노드 제거
2. 가장자리 제거
3. 무한 가중치 가장자리

-- 다익스트라 알고리즘, 합리적이지못한곳 탐색 => 느리다.
-- Greedy Best-First-Search, 스캔한 영역, 목표에 가장 가까운 정점 선택 => 빠르다.
-- 다익스트라 + Greedy  = A* (1968)
-- Dijkstra(시작점에가까운정점선호) + Greedy(목표에가까운정점선호)
-- 휴리스틱 h(n) =>해당정점에서 목표지점까지의 '최소비용 추정치'
=> 효과적인 휴리스틱함수사용의 중요성 ex) h(n) = 0 , 다익스트라 (극단적예시)
-- 속도와 정확도 사이의 균형 이용
-- 유클리드 거리, 제곱
-- h(n) 의 영향력 에 따라 달라지는 최단경로
-- 과정 및 구현

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*유클리드 거리
-- L2 Distance
-- ex) Vec(10,10,10) -  Vec(0, 0, 0),, 거리, 방향 동시에

*맨해튼 거리
-- L1 Distance
-- A(X1, Y1), B(X2, Y2) => | X1 - X2 | + | Y1 - Y2 |
=> (A - B) (유클리드,최단) 이면, 높이 + 밑변 ( 맨하탄 )

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

@C++ 기초 플러스 돌아보기

*코드의 재활용
-- has-a 관계,, 초기화리스트해주지 않는다면??
-- 초기화 리스트 문법의 '초기화 순서'
-- 내포된 객체(Component)(=has-a) 의 인터페이스
-- private 상속, has-a 관계
-- 두가지 방식의 차이점?? 구현방식의차이
-- private 상속의 함수 호출, 객체리턴, 
-- private 상속, 효과적일 수 있는 2가지 상황(protected멤버, 가상함수)
-- protected 상속, => private 상속 과 차이점
-- 다중상속 문제점 =>여러인스턴스
-- 가상 기초 클래스 ( virtual base class )
-- 가상기초 가 왜 다중상속의 표본이 아닌가??
-- 새로운 생성자 규칙,, 잠재적 충돌 => 명시적 호출
-- 어느 함수를 호출하는가??
-- 가상기초클래스 와 가상이 아닌 클래스의 혼합
-- 가상기초클래스 와 비교우위
