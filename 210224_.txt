@알고리즘

*DP 점화식 세우기 연습(DP 공간을 어떻게 잡을것인가)

-- 201208 BaekJoon 1학년
=>현재값을 가지고 확인. Dp[전체길이][나올수있는수]

-- 201208 BaekJoon 게임
=> Dp[보드판Y][보드판X], 해당보드에 들어오기만하면 그값은 일정.
=> Loop 는 어떻게 판별할것인가??, 재귀의 진행 여부

-- 201208 BaekJoon 미친로봇
=> 백트래킹(DFS)

-- 201208 방배정하기
=> Dp[N*2], 반복적 동적계획법, 브루트포스 이용가능

-- 201208 파이프 옮기기
=> Dp[보드판Y][보드판X][방향], 보드판(Y,X) 에 도달했을 때의 각방향(마지막단계)
=> 해당방향이 가능한지, 반복적동적계획법으로는??
=> Dp[][] 는 바뀌지 않음. 재귀(갔다가온다), 반복적DP(선행적),

-- 201210 내리막길
=> Dp[보드판Y][보드판X] 
=> 해당보드판(Y,X) 에서 내리막조건으로 (N,N) 까지 갈 수 있는 경우의수

-- 201210 동물원
=> Dp[N칸][3], 첫번째 , 두번째, 선택않음.
=> 부분문제의도출, 마지막 해당칸에 대해 들어올수있는 경우(최대가지수)
=> 2*N 의 칸에서 선택되지않는 칸을 임의로 넣어줌, 따라서 Dp[N][3]


@C++ 기초플러스 돌아보기

*역참조포인터

*템플릿
-- 함수템플릿, 일반화서술, 정의하는방법, 정의생성
-- 템플릿의 장점
-- 컴파일러 함수 선택 우선순위
-- 함수템플릿 특수화 => 명시적 특수화,
```
template<class T>
T Plus(T A, T B)
{ return A + B; }

@명시적특수화
template<> int Plus<int>(int A, int B)
{ return A + B + 10; }

@오래된 명시적특수화
int Plus<int>(int A, int B)
```

-- 함수템플릿에서의 부분특수화 => 불가능, 무엇으로해결??, 그렇다면 우선순위는??
-- 명시적특수화에서의 참조
```
//@Template - 모호한상황 =>명시적특수화 
	int N1 = 10, N2 = 10; 
	int& TT = Plus<int&>(N1, N2); //OK 
	//int& TTT = Plus(N1, N2); //ERROR
```

-- 암시적 구체화, 명시적 구체화
