@C++ 기초플러스 돌아보기

*클래스와 동적메모리 대입
-- StringBad,  str = s (X)
-- 객체안의포인터, 복사, 대입 생성자
-- 복사, 대입 연산자 의 필요성
-- 기본 복사, 대입 연산자의 과정 => 값복사
-- 명시적 복사, 대입 연산자 구현,, 얕은복사 깊은복사
-- StringBad thing = alive,  동작과정
-- 대입연산자가 StringBad& 참조를 리턴하는 이유
-- string 클래스, operator[], opeartor>, <, 
-- string::operator(const char *), (const string& A)
-- 생성자에서의 new, delete => delete 연산자 nullptr 에 적용가능
-- Magazine class { private: StringGood SG; }
-- const 객체, 아닌 객체 에 대한 참조리턴
-- const 객체리턴 => force1 + force2 = net
-- 위치지정 new => 사용자관리필수적 => 파괴자의 명시적호출의 드문경우



@알고리즘 ( 종만북 ) 

*동적계획법 ( DP )
-- 서로연관되는,의존,반복 의 문제 =>ex) 이항계수
-- 계산중복의횟수 => 지수적증가
-- 이 떄, 참조적투명 적용 => 반환값 일정
-- 시간복잡도분석 => 존재하는 부분문제의수 * 한부분문제의반복문횟수
-- Dp의 입력값 설정 ( 꼭 필요한 정보인가 )
=> 해결하지못한 조각들을 정의하는 입력, 이미 결정한 조각들에 대한 정보
=> 더 작은 부분문제로 갈 수 있는 꼭 필요한 정보
-- 최적 부분 구조
-- ex) 합친 LIS , 기존알고리즘 변형 과정, NlogN 알고리즘 => 과정상기하기
-- ex) 원주율 외우기


*DP 를 적용할 수 있는 문제의 실마리?
0. 모든 경우의수를 구할 때, ( 보통 DFS )
1. 완전탐색
2. 참조적 투명성이 적용되는지
3. 부분문제로 나뉘어지는가, 어떤 부분이 서로 반복되는가
4. 어떻게 나눌것인가??, 일관된값이나오는함수의 파라미터,,


*알고리즘 문제풀어보기
-- BaekJoon 스티커 https://www.acmicpc.net/problem/9465

